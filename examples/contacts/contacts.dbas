' Contact Book - Win32 SQLite Application
' Demonstrates Go package integration with Walk GUI and SQLite database
'
' This example shows DBasic syntax for a Win32 GUI application using:
' - Multi-line struct literals: Type{ field1: value1, field2: value2 }
' - Slice literals: []Type{ elem1, elem2 }
' - Nested struct/slice literals for declarative UI definitions
'
' Due to Walk requiring Go interface implementation (TableModel),
' the actual executable is built from the Go source (main.go).

IMPORT "database/sql"
IMPORT "fmt"
IMPORT "os"
IMPORT "path/filepath"
IMPORT "sort"
IMPORT "github.com/lxn/walk"
IMPORT "github.com/lxn/walk/declarative"
IMPORT "modernc.org/sqlite"

' Contact record structure
TYPE Contact
    DIM ID AS LONG
    DIM FirstName AS STRING
    DIM LastName AS STRING
    DIM Address AS STRING
    DIM City AS STRING
    DIM State AS STRING
    DIM Zip AS STRING
    DIM Phone AS STRING
    DIM Email AS STRING
END TYPE

' Application state
TYPE Application
    DIM mainWindow AS walk.MainWindow
    DIM tableView AS walk.TableView
    DIM statusBar AS walk.StatusBarItem
    DIM db AS sql.DB
    DIM contacts AS []Contact
    DIM sortColumn AS INTEGER
    DIM sortAscending AS BOOLEAN
END TYPE

' Global application instance
DIM app AS Application

' ============================================================================
' Database Functions
' ============================================================================

FUNCTION InitDatabase(dbPath AS STRING) AS sql.DB
    DIM db AS sql.DB
    DIM err AS ERROR

    db, err = sql.Open("sqlite", dbPath)
    IF err <> NIL THEN
        PRINT "Failed to open database:"; err
        RETURN NIL
    END IF

    RETURN db
END FUNCTION

SUB CreateContactsTable(db AS sql.DB)
    DIM query AS STRING
    query = "CREATE TABLE IF NOT EXISTS contacts (" + _
            "id INTEGER PRIMARY KEY AUTOINCREMENT, " + _
            "first_name TEXT NOT NULL, " + _
            "last_name TEXT NOT NULL, " + _
            "address TEXT, " + _
            "city TEXT, " + _
            "state TEXT, " + _
            "zip TEXT, " + _
            "phone TEXT, " + _
            "email TEXT)"

    db.Exec(query)
END SUB

FUNCTION GetAllContacts(db AS sql.DB, sortBy AS STRING, sortAsc AS BOOLEAN) AS []Contact
    DIM contacts AS []Contact
    DIM orderDir AS STRING

    IF sortAsc THEN
        orderDir = "ASC"
    ELSE
        orderDir = "DESC"
    END IF

    DIM query AS STRING
    query = "SELECT id, first_name, last_name, address, city, state, zip, phone, email " + _
            "FROM contacts ORDER BY " + sortBy + " " + orderDir

    DIM rows AS sql.Rows
    rows = db.Query(query)

    DO WHILE rows.Next()
        DIM c AS Contact
        rows.Scan(@c.ID, @c.FirstName, @c.LastName, @c.Address, @c.City, @c.State, @c.Zip, @c.Phone, @c.Email)
        contacts = APPEND(contacts, c)
    LOOP

    rows.Close()
    RETURN contacts
END FUNCTION

SUB InsertContact(db AS sql.DB, c AS Contact)
    DIM query AS STRING
    query = "INSERT INTO contacts (first_name, last_name, address, city, state, zip, phone, email) " + _
            "VALUES (?, ?, ?, ?, ?, ?, ?, ?)"

    db.Exec(query, c.FirstName, c.LastName, c.Address, c.City, c.State, c.Zip, c.Phone, c.Email)
END SUB

SUB UpdateContact(db AS sql.DB, c AS Contact)
    DIM query AS STRING
    query = "UPDATE contacts SET first_name=?, last_name=?, address=?, city=?, state=?, zip=?, phone=?, email=? " + _
            "WHERE id=?"

    db.Exec(query, c.FirstName, c.LastName, c.Address, c.City, c.State, c.Zip, c.Phone, c.Email, c.ID)
END SUB

SUB DeleteContact(db AS sql.DB, id AS LONG)
    db.Exec("DELETE FROM contacts WHERE id=?", id)
END SUB

FUNCTION SearchContacts(db AS sql.DB, searchTerm AS STRING) AS []Contact
    DIM contacts AS []Contact
    DIM pattern AS STRING
    pattern = "%" + searchTerm + "%"

    DIM query AS STRING
    query = "SELECT id, first_name, last_name, address, city, state, zip, phone, email " + _
            "FROM contacts WHERE " + _
            "first_name LIKE ? OR last_name LIKE ? OR city LIKE ? OR state LIKE ? OR phone LIKE ?"

    DIM rows AS sql.Rows
    rows = db.Query(query, pattern, pattern, pattern, pattern, pattern)

    DO WHILE rows.Next()
        DIM c AS Contact
        rows.Scan(@c.ID, @c.FirstName, @c.LastName, @c.Address, @c.City, @c.State, @c.Zip, @c.Phone, @c.Email)
        contacts = APPEND(contacts, c)
    LOOP

    rows.Close()
    RETURN contacts
END FUNCTION

' ============================================================================
' Seed Data - Fictional TV Characters
' Using slice literal syntax for declarative data definition
' ============================================================================

SUB SeedDatabase(db AS sql.DB)
    ' Check if already seeded
    DIM count AS INTEGER
    db.QueryRow("SELECT COUNT(*) FROM contacts").Scan(@count)
    IF count > 0 THEN RETURN

    ' Define TV character contacts using slice literal syntax
    DIM seedContacts AS []Contact = []Contact{
        Contact{
            FirstName: "Herman",
            LastName: "Munster",
            Address: "1313 Mockingbird Lane",
            City: "Mockingbird Heights",
            State: "CA",
            Zip: "90210",
            Phone: "555-555-0001",
            Email: "herman.munster@mockingbird.example"
        },
        Contact{
            FirstName: "Gomez",
            LastName: "Addams",
            Address: "0001 Cemetery Lane",
            City: "Westfield",
            State: "NJ",
            Zip: "07090",
            Phone: "555-555-0002",
            Email: "gomez.addams@cemetery.example"
        },
        Contact{
            FirstName: "Fred",
            LastName: "Flintstone",
            Address: "301 Cobblestone Way",
            City: "Bedrock",
            State: "",
            Zip: "00001",
            Phone: "555-555-0003",
            Email: "fred.flintstone@bedrock.example"
        },
        Contact{
            FirstName: "Homer",
            LastName: "Simpson",
            Address: "742 Evergreen Terrace",
            City: "Springfield",
            State: "",
            Zip: "49007",
            Phone: "555-555-0005",
            Email: "homer.simpson@springfield.example"
        },
        Contact{
            FirstName: "Al",
            LastName: "Bundy",
            Address: "9764 Jeopardy Lane",
            City: "Chicago",
            State: "IL",
            Zip: "60614",
            Phone: "555-555-0007",
            Email: "al.bundy@chicago.example"
        },
        Contact{
            FirstName: "Walter",
            LastName: "White",
            Address: "308 Negra Arroyo Lane",
            City: "Albuquerque",
            State: "NM",
            Zip: "87104",
            Phone: "555-555-0022",
            Email: "walter.white@jpwynne.example"
        },
        Contact{
            FirstName: "Michael",
            LastName: "Scott",
            Address: "1725 Slough Avenue",
            City: "Scranton",
            State: "PA",
            Zip: "18503",
            Phone: "555-555-0024",
            Email: "michael.scott@dundermifflin.example"
        }
    }

    ' Insert all seed contacts
    DIM i AS INTEGER
    FOR i = 0 TO LEN(seedContacts) - 1
        InsertContact(db, seedContacts[i])
    NEXT i
END SUB

' ============================================================================
' Event Handlers
' ============================================================================

SUB OnNewContact()
    DIM c AS Contact
    IF ShowContactDialog(@c, "New Contact") THEN
        InsertContact(app.db, c)
        RefreshContacts()
    END IF
END SUB

SUB OnEditContact()
    DIM index AS INTEGER
    index = app.tableView.CurrentIndex()
    IF index < 0 THEN
        walk.MsgBox(app.mainWindow, "No Selection", "Please select a contact to edit.", walk.MsgBoxIconInformation)
        RETURN
    END IF

    DIM c AS Contact
    c = app.contacts[index]

    IF ShowContactDialog(@c, "Edit Contact") THEN
        UpdateContact(app.db, c)
        RefreshContacts()
    END IF
END SUB

SUB OnDeleteContact()
    DIM index AS INTEGER
    index = app.tableView.CurrentIndex()
    IF index < 0 THEN
        walk.MsgBox(app.mainWindow, "No Selection", "Please select a contact to delete.", walk.MsgBoxIconInformation)
        RETURN
    END IF

    DIM c AS Contact
    c = app.contacts[index]

    DIM result AS INTEGER
    result = walk.MsgBox(app.mainWindow, "Confirm Delete", _
                         "Are you sure you want to delete " + c.FirstName + " " + c.LastName + "?", _
                         walk.MsgBoxYesNo + walk.MsgBoxIconQuestion)

    IF result = walk.DlgCmdYes THEN
        DeleteContact(app.db, c.ID)
        RefreshContacts()
    END IF
END SUB

SUB RefreshContacts()
    DIM sortBy AS STRING
    SELECT CASE app.sortColumn
        CASE 0: sortBy = "first_name"
        CASE 1: sortBy = "last_name"
        CASE 2: sortBy = "city"
        CASE 3: sortBy = "state"
        CASE 4: sortBy = "phone"
    END SELECT

    app.contacts = GetAllContacts(app.db, sortBy, app.sortAscending)
    app.tableView.Invalidate()
    UpdateStatus()
END SUB

SUB UpdateStatus()
    DIM count AS INTEGER
    count = LEN(app.contacts)
    app.statusBar.SetText(Str(count) + " contacts")
END SUB

FUNCTION ShowContactDialog(c AS ^Contact, title AS STRING) AS BOOLEAN
    ' Create modal dialog for editing contact
    ' Returns TRUE if user clicked OK, FALSE if cancelled

    DIM dlg AS walk.Dialog
    DIM firstNameEdit AS walk.LineEdit
    DIM lastNameEdit AS walk.LineEdit
    DIM addressEdit AS walk.LineEdit
    DIM cityEdit AS walk.LineEdit
    DIM stateEdit AS walk.LineEdit
    DIM zipEdit AS walk.LineEdit
    DIM phoneEdit AS walk.LineEdit
    DIM emailEdit AS walk.LineEdit

    ' ... dialog creation code using walk.declarative
    ' ... set field values from c^
    ' ... on OK, copy values back to c^

    RETURN dlg.Result() = walk.DlgCmdOK
END FUNCTION

' ============================================================================
' Main Entry Point
' ============================================================================

SUB Main()
    ' Get database path
    DIM exePath AS STRING
    exePath = os.Executable()
    DIM dbPath AS STRING
    dbPath = filepath.Join(filepath.Dir(exePath), "contacts.db")

    ' Initialize database
    app.db = InitDatabase(dbPath)
    IF app.db = NIL THEN
        walk.MsgBox(NIL, "Error", "Failed to initialize database", walk.MsgBoxIconError)
        RETURN
    END IF

    ' Create tables and seed data
    CreateContactsTable(app.db)
    SeedDatabase(app.db)

    ' Set default sort
    app.sortColumn = 1  ' Last name
    app.sortAscending = TRUE

    ' Load contacts
    app.contacts = GetAllContacts(app.db, "last_name", TRUE)

    ' Create and run main window using Walk's declarative API
    ' Note: This is now possible with DBasic's multi-line struct and slice literals!
    '
    ' Example of how this would look in DBasic:
    '
    ' declarative.MainWindow{
    '     AssignTo: @app.mainWindow,
    '     Title: "Contact Book",
    '     MinSize: declarative.Size{Width: 600, Height: 400},
    '     Size: declarative.Size{Width: 800, Height: 600},
    '     Layout: declarative.VBox{},
    '     MenuItems: []declarative.MenuItem{
    '         declarative.Menu{
    '             Text: "&File",
    '             Items: []declarative.MenuItem{
    '                 declarative.Action{
    '                     Text: "&New\tCtrl+N",
    '                     OnTriggered: OnNewContact
    '                 },
    '                 declarative.Action{
    '                     Text: "&Edit\tCtrl+E",
    '                     OnTriggered: OnEditContact
    '                 },
    '                 declarative.Separator{},
    '                 declarative.Action{
    '                     Text: "E&xit\tAlt+F4",
    '                     OnTriggered: ExitApp
    '                 }
    '             }
    '         }
    '     },
    '     Children: []declarative.Widget{
    '         declarative.TableView{
    '             AssignTo: @app.tableView,
    '             Columns: []declarative.TableViewColumn{
    '                 declarative.TableViewColumn{Title: "First Name", Width: 100},
    '                 declarative.TableViewColumn{Title: "Last Name", Width: 100},
    '                 declarative.TableViewColumn{Title: "City", Width: 120},
    '                 declarative.TableViewColumn{Title: "State", Width: 50},
    '                 declarative.TableViewColumn{Title: "Phone", Width: 120}
    '             }
    '         }
    '     },
    '     StatusBarItems: []declarative.StatusBarItem{
    '         declarative.StatusBarItem{
    '             AssignTo: @app.statusBar,
    '             Text: "Ready"
    '         }
    '     }
    ' }.Run()
    '
    ' Note: The actual implementation uses main.go because Walk's TableModel
    ' interface requires Go method implementation. Future DBasic versions may
    ' support interface implementation directly.

    app.mainWindow.Run()

    ' Cleanup
    app.db.Close()
END SUB
