' DOS 5.0 EDIT.COM Clone - DBasic Text Editor
' A faithful recreation of the classic MS-DOS Editor
' Written entirely in DBasic with no hand-written Go

IMPORT "github.com/charmbracelet/bubbletea" AS tea
IMPORT "github.com/charmbracelet/lipgloss" AS lipgloss
IMPORT "fmt" AS fmt
IMPORT "strings" AS strings
IMPORT "os" AS os

' Menu state constants
CONST MENU_NONE AS INTEGER = 0
CONST MENU_FILE AS INTEGER = 1
CONST MENU_EDIT AS INTEGER = 2
CONST MENU_SEARCH AS INTEGER = 3
CONST MENU_OPTIONS AS INTEGER = 4
CONST MENU_HELP AS INTEGER = 5

' Dialog state constants
CONST DIALOG_NONE AS INTEGER = 0
CONST DIALOG_HELP AS INTEGER = 1
CONST DIALOG_ABOUT AS INTEGER = 2
CONST DIALOG_OPEN AS INTEGER = 3
CONST DIALOG_SAVE AS INTEGER = 4
CONST DIALOG_SAVEAS AS INTEGER = 5
CONST DIALOG_FIND AS INTEGER = 6
CONST DIALOG_REPLACE AS INTEGER = 7
CONST DIALOG_GOTO AS INTEGER = 8
CONST DIALOG_CONFIRM_NEW AS INTEGER = 9
CONST DIALOG_CONFIRM_EXIT AS INTEGER = 10

' Editor state structure
TYPE EditorModel IMPLEMENTS tea.Model
    ' Cursor position (0-indexed)
    DIM CursorX AS INTEGER
    DIM CursorY AS INTEGER

    ' Screen dimensions
    DIM Width AS INTEGER
    DIM Height AS INTEGER

    ' Text lines stored as newline-separated string
    DIM Content AS STRING
    DIM LineCount AS INTEGER

    ' Scroll position
    DIM ScrollX AS INTEGER
    DIM ScrollY AS INTEGER

    ' Selection (for copy/paste)
    DIM SelectStartX AS INTEGER
    DIM SelectStartY AS INTEGER
    DIM SelectEndX AS INTEGER
    DIM SelectEndY AS INTEGER
    DIM Selecting AS BOOLEAN

    ' Clipboard
    DIM Clipboard AS STRING

    ' File info
    DIM Filename AS STRING
    DIM Modified AS BOOLEAN

    ' Menu state
    DIM MenuOpen AS INTEGER
    DIM MenuIndex AS INTEGER

    ' Dialog state
    DIM DialogMode AS INTEGER
    DIM DialogInput AS STRING
    DIM DialogCursor AS INTEGER

    ' Search state
    DIM SearchText AS STRING
    DIM ReplaceText AS STRING
    DIM SearchWrap AS BOOLEAN
    DIM SearchCase AS BOOLEAN

    ' Status message
    DIM Message AS STRING

    ' Options
    DIM ShowLineNumbers AS BOOLEAN
    DIM TabSize AS INTEGER
    DIM InsertMode AS BOOLEAN
END TYPE

' Styles - DOS blue theme
DIM menuBarStyle AS lipgloss.Style
DIM menuItemStyle AS lipgloss.Style
DIM menuItemSelectedStyle AS lipgloss.Style
DIM menuHotkeyStyle AS lipgloss.Style
DIM menuHotkeySelectedStyle AS lipgloss.Style
DIM menuDropdownStyle AS lipgloss.Style
DIM textAreaStyle AS lipgloss.Style
DIM statusBarStyle AS lipgloss.Style
DIM dialogStyle AS lipgloss.Style
DIM dialogTitleStyle AS lipgloss.Style
DIM lineNumStyle AS lipgloss.Style
DIM cursorStyle AS lipgloss.Style
DIM selectedStyle AS lipgloss.Style

' Initialize DOS-style colors
SUB InitStyles()
    ' Menu bar - white on gray (like DOS)
    menuBarStyle = lipgloss.NewStyle().Background(lipgloss.Color("7")).Foreground(lipgloss.Color("0"))
    menuItemStyle = lipgloss.NewStyle().Background(lipgloss.Color("7")).Foreground(lipgloss.Color("0"))
    menuItemSelectedStyle = lipgloss.NewStyle().Background(lipgloss.Color("0")).Foreground(lipgloss.Color("7"))
    ' Hotkey - red on gray for unselected, red on black for selected
    menuHotkeyStyle = lipgloss.NewStyle().Background(lipgloss.Color("7")).Foreground(lipgloss.Color("1"))
    menuHotkeySelectedStyle = lipgloss.NewStyle().Background(lipgloss.Color("0")).Foreground(lipgloss.Color("9"))

    ' Dropdown menu - white on blue
    menuDropdownStyle = lipgloss.NewStyle().Background(lipgloss.Color("4")).Foreground(lipgloss.Color("15")).Border(lipgloss.NormalBorder()).BorderForeground(lipgloss.Color("15"))

    ' Text area - white on blue (classic DOS look)
    textAreaStyle = lipgloss.NewStyle().Background(lipgloss.Color("4")).Foreground(lipgloss.Color("15"))

    ' Status bar - black on cyan
    statusBarStyle = lipgloss.NewStyle().Background(lipgloss.Color("6")).Foreground(lipgloss.Color("0"))

    ' Dialog box
    dialogStyle = lipgloss.NewStyle().Background(lipgloss.Color("7")).Foreground(lipgloss.Color("0")).Border(lipgloss.DoubleBorder()).BorderForeground(lipgloss.Color("0")).Padding(1, 2)
    dialogTitleStyle = lipgloss.NewStyle().Background(lipgloss.Color("4")).Foreground(lipgloss.Color("15")).Padding(0, 1)

    ' Line numbers
    lineNumStyle = lipgloss.NewStyle().Background(lipgloss.Color("4")).Foreground(lipgloss.Color("8"))

    ' Cursor - reverse video
    cursorStyle = lipgloss.NewStyle().Background(lipgloss.Color("15")).Foreground(lipgloss.Color("4"))

    ' Selected text
    selectedStyle = lipgloss.NewStyle().Background(lipgloss.Color("3")).Foreground(lipgloss.Color("0"))
END SUB

' String helper: repeat character
FUNCTION RepeatChar(ch AS STRING, count AS INTEGER) AS STRING
    DIM result AS STRING = ""
    DIM i AS INTEGER
    FOR i = 1 TO count
        result = result & ch
    NEXT
    RETURN result
END FUNCTION

' String helper: pad string to width
FUNCTION PadRight(s AS STRING, width AS INTEGER) AS STRING
    IF Len(s) >= width THEN
        RETURN Left(s, width)
    ENDIF
    RETURN s & RepeatChar(" ", width - Len(s))
END FUNCTION

' String helper: center string
FUNCTION CenterStr(s AS STRING, width AS INTEGER) AS STRING
    IF Len(s) >= width THEN
        RETURN Left(s, width)
    ENDIF
    DIM padding AS INTEGER = (width - Len(s)) / 2
    RETURN RepeatChar(" ", padding) & s & RepeatChar(" ", width - Len(s) - padding)
END FUNCTION

' Count lines in content
FUNCTION CountLines(content AS STRING) AS INTEGER
    IF Len(content) = 0 THEN
        RETURN 1
    ENDIF
    DIM count AS INTEGER = 1
    DIM i AS INTEGER
    FOR i = 1 TO Len(content)
        IF Mid(content, i, 1) = Chr(10) THEN
            count = count + 1
        ENDIF
    NEXT
    RETURN count
END FUNCTION

' Get a specific line from content (1-indexed)
FUNCTION GetLine(content AS STRING, lineNum AS INTEGER) AS STRING
    IF Len(content) = 0 THEN
        RETURN ""
    ENDIF
    DIM currentLine AS INTEGER = 1
    DIM startPos AS INTEGER = 1
    DIM i AS INTEGER

    FOR i = 1 TO Len(content)
        IF currentLine = lineNum THEN
            startPos = i
            EXIT FOR
        ENDIF
        IF Mid(content, i, 1) = Chr(10) THEN
            currentLine = currentLine + 1
        ENDIF
    NEXT

    IF currentLine < lineNum THEN
        RETURN ""
    ENDIF

    DIM result AS STRING = ""
    FOR i = startPos TO Len(content)
        DIM ch AS STRING = Mid(content, i, 1)
        IF ch = Chr(10) THEN
            EXIT FOR
        ENDIF
        result = result & ch
    NEXT

    RETURN result
END FUNCTION

' Get line length
FUNCTION GetLineLength(content AS STRING, lineNum AS INTEGER) AS INTEGER
    RETURN Len(GetLine(content, lineNum))
END FUNCTION

' Set a specific line in content (1-indexed)
FUNCTION SetLine(content AS STRING, lineNum AS INTEGER, newLine AS STRING) AS STRING
    DIM lines AS STRING = ""
    DIM currentLine AS INTEGER = 1
    DIM i AS INTEGER
    DIM lineStart AS INTEGER = 1

    FOR i = 1 TO Len(content) + 1
        DIM ch AS STRING = ""
        IF i <= Len(content) THEN
            ch = Mid(content, i, 1)
        ENDIF

        IF ch = Chr(10) OR i > Len(content) THEN
            IF currentLine = lineNum THEN
                lines = lines & newLine
            ELSE
                lines = lines & Mid(content, lineStart, i - lineStart)
            ENDIF

            IF ch = Chr(10) THEN
                lines = lines & Chr(10)
            ENDIF

            currentLine = currentLine + 1
            lineStart = i + 1
        ENDIF
    NEXT

    RETURN lines
END FUNCTION

' Insert character at position
FUNCTION InsertCharAt(content AS STRING, lineNum AS INTEGER, col AS INTEGER, ch AS STRING) AS STRING
    DIM line AS STRING = GetLine(content, lineNum)
    DIM newLine AS STRING

    IF col <= 0 THEN
        newLine = ch & line
    ELSEIF col >= Len(line) THEN
        newLine = line & ch
    ELSE
        newLine = Left(line, col) & ch & Mid(line, col + 1, Len(line) - col)
    ENDIF

    RETURN SetLine(content, lineNum, newLine)
END FUNCTION

' Delete character at position
FUNCTION DeleteCharAt(content AS STRING, lineNum AS INTEGER, col AS INTEGER) AS STRING
    DIM line AS STRING = GetLine(content, lineNum)

    IF col < 0 OR col >= Len(line) THEN
        RETURN content
    ENDIF

    DIM newLine AS STRING
    IF col = 0 THEN
        newLine = Mid(line, 2, Len(line) - 1)
    ELSE
        newLine = Left(line, col) & Mid(line, col + 2, Len(line) - col - 1)
    ENDIF

    RETURN SetLine(content, lineNum, newLine)
END FUNCTION

' Insert new line
FUNCTION InsertNewLine(content AS STRING, lineNum AS INTEGER, col AS INTEGER) AS STRING
    DIM line AS STRING = GetLine(content, lineNum)
    DIM beforeCursor AS STRING = Left(line, col)
    DIM afterCursor AS STRING = Mid(line, col + 1, Len(line) - col)

    DIM result AS STRING = ""
    DIM currentLine AS INTEGER = 1
    DIM i AS INTEGER
    DIM lineStart AS INTEGER = 1

    FOR i = 1 TO Len(content) + 1
        DIM ch AS STRING = ""
        IF i <= Len(content) THEN
            ch = Mid(content, i, 1)
        ENDIF

        IF ch = Chr(10) OR i > Len(content) THEN
            IF currentLine = lineNum THEN
                result = result & beforeCursor & Chr(10) & afterCursor
            ELSE
                result = result & Mid(content, lineStart, i - lineStart)
            ENDIF

            IF ch = Chr(10) AND currentLine <> lineNum THEN
                result = result & Chr(10)
            ENDIF

            currentLine = currentLine + 1
            lineStart = i + 1
        ENDIF
    NEXT

    RETURN result
END FUNCTION

' Delete line and join with previous
FUNCTION JoinWithPrevLine(content AS STRING, lineNum AS INTEGER) AS STRING
    IF lineNum <= 1 THEN
        RETURN content
    ENDIF

    DIM prevLine AS STRING = GetLine(content, lineNum - 1)
    DIM currLine AS STRING = GetLine(content, lineNum)
    DIM joinedLine AS STRING = prevLine & currLine

    ' Rebuild content without the current line
    DIM result AS STRING = ""
    DIM currentLine AS INTEGER = 1
    DIM i AS INTEGER
    DIM lineStart AS INTEGER = 1

    FOR i = 1 TO Len(content) + 1
        DIM ch AS STRING = ""
        IF i <= Len(content) THEN
            ch = Mid(content, i, 1)
        ENDIF

        IF ch = Chr(10) OR i > Len(content) THEN
            IF currentLine = lineNum - 1 THEN
                result = result & joinedLine
            ELSEIF currentLine <> lineNum THEN
                result = result & Mid(content, lineStart, i - lineStart)
            ENDIF

            IF ch = Chr(10) AND currentLine <> lineNum - 1 AND currentLine <> lineNum THEN
                result = result & Chr(10)
            ELSEIF ch = Chr(10) AND currentLine = lineNum - 1 THEN
                ' Skip the newline after prev line since we're joining
            ELSEIF ch = Chr(10) AND currentLine < lineNum - 1 THEN
                result = result & Chr(10)
            ENDIF

            currentLine = currentLine + 1
            lineStart = i + 1
        ENDIF
    NEXT

    RETURN result
END FUNCTION

' Initialize the model
FUNCTION (m AS EditorModel) Init() AS tea.Cmd
    InitStyles()
    RETURN NIL
END FUNCTION

' Update handles all messages
FUNCTION (m AS EditorModel) Update(msg AS tea.Msg) AS (tea.Model, tea.Cmd)
    ' Handle window size
    DIM sizeMsg AS tea.WindowSizeMsg
    DIM sizeOk AS BOOLEAN
    sizeMsg, sizeOk = msg.(tea.WindowSizeMsg)
    IF sizeOk THEN
        m.Width = Int(sizeMsg.Width)
        m.Height = Int(sizeMsg.Height)
        RETURN m, NIL
    ENDIF

    ' Handle key messages
    DIM keyMsg AS tea.KeyMsg
    DIM ok AS BOOLEAN
    keyMsg, ok = msg.(tea.KeyMsg)

    IF NOT ok THEN
        RETURN m, NIL
    ENDIF

    DIM key AS STRING = keyMsg.String()

    ' Dialog input handling
    IF m.DialogMode <> DIALOG_NONE THEN
        RETURN HandleDialogInput(m, key)
    ENDIF

    ' Menu handling
    IF m.MenuOpen <> MENU_NONE THEN
        RETURN HandleMenuInput(m, key)
    ENDIF

    ' Global shortcuts
    IF key = "alt+f" OR key = "f10" THEN
        m.MenuOpen = MENU_FILE
        m.MenuIndex = 0
        RETURN m, NIL
    ELSEIF key = "alt+e" THEN
        m.MenuOpen = MENU_EDIT
        m.MenuIndex = 0
        RETURN m, NIL
    ELSEIF key = "alt+s" THEN
        m.MenuOpen = MENU_SEARCH
        m.MenuIndex = 0
        RETURN m, NIL
    ELSEIF key = "alt+o" THEN
        m.MenuOpen = MENU_OPTIONS
        m.MenuIndex = 0
        RETURN m, NIL
    ELSEIF key = "alt+h" OR key = "f1" THEN
        m.DialogMode = DIALOG_HELP
        RETURN m, NIL
    ELSEIF key = "ctrl+n" THEN
        RETURN DoNewFile(m)
    ELSEIF key = "ctrl+o" THEN
        m.DialogMode = DIALOG_OPEN
        m.DialogInput = m.Filename
        m.DialogCursor = Len(m.DialogInput)
        RETURN m, NIL
    ELSEIF key = "ctrl+s" THEN
        RETURN DoSaveFile(m)
    ELSEIF key = "ctrl+q" OR key = "alt+x" THEN
        IF m.Modified THEN
            m.DialogMode = DIALOG_CONFIRM_EXIT
            RETURN m, NIL
        ENDIF
        RETURN m, tea.Quit
    ELSEIF key = "ctrl+f" THEN
        m.DialogMode = DIALOG_FIND
        m.DialogInput = m.SearchText
        m.DialogCursor = Len(m.DialogInput)
        RETURN m, NIL
    ELSEIF key = "ctrl+h" THEN
        m.DialogMode = DIALOG_REPLACE
        m.DialogInput = m.SearchText
        m.DialogCursor = Len(m.DialogInput)
        RETURN m, NIL
    ELSEIF key = "f3" THEN
        RETURN DoFindNext(m)
    ELSEIF key = "ctrl+g" THEN
        m.DialogMode = DIALOG_GOTO
        m.DialogInput = ""
        m.DialogCursor = 0
        RETURN m, NIL
    ELSEIF key = "ctrl+c" THEN
        RETURN DoCopy(m)
    ELSEIF key = "ctrl+x" THEN
        RETURN DoCut(m)
    ELSEIF key = "ctrl+v" THEN
        RETURN DoPaste(m)
    ELSEIF key = "ctrl+a" THEN
        RETURN DoSelectAll(m)
    ELSEIF key = "insert" THEN
        m.InsertMode = NOT m.InsertMode
        IF m.InsertMode THEN
            m.Message = "Insert mode"
        ELSE
            m.Message = "Overwrite mode"
        ENDIF
        RETURN m, NIL
    ENDIF

    ' Navigation and editing
    RETURN HandleEditorInput(m, key)
END FUNCTION

' Start or extend selection
SUB StartSelection(m AS POINTER TO EditorModel)
    IF NOT (^m).Selecting THEN
        (^m).Selecting = TRUE
        (^m).SelectStartX = (^m).CursorX
        (^m).SelectStartY = (^m).CursorY
    ENDIF
END SUB

' Clear selection
SUB ClearSelection(m AS POINTER TO EditorModel)
    (^m).Selecting = FALSE
END SUB

' Handle editor input (navigation and text editing)
FUNCTION HandleEditorInput(m AS EditorModel, key AS STRING) AS (tea.Model, tea.Cmd)
    DIM totalLines AS INTEGER = CountLines(m.Content)
    DIM currentLineLen AS INTEGER = GetLineLength(m.Content, m.CursorY + 1)

    ' Shift+arrow selection
    IF key = "shift+left" THEN
        StartSelection(@m)
        IF m.CursorX > 0 THEN
            m.CursorX = m.CursorX - 1
        ELSEIF m.CursorY > 0 THEN
            m.CursorY = m.CursorY - 1
            m.CursorX = GetLineLength(m.Content, m.CursorY + 1)
        ENDIF
        m.SelectEndX = m.CursorX
        m.SelectEndY = m.CursorY
        RETURN m, NIL

    ELSEIF key = "shift+right" THEN
        StartSelection(@m)
        IF m.CursorX < currentLineLen THEN
            m.CursorX = m.CursorX + 1
        ELSEIF m.CursorY < totalLines - 1 THEN
            m.CursorY = m.CursorY + 1
            m.CursorX = 0
        ENDIF
        m.SelectEndX = m.CursorX
        m.SelectEndY = m.CursorY
        RETURN m, NIL

    ELSEIF key = "shift+up" THEN
        StartSelection(@m)
        IF m.CursorY > 0 THEN
            m.CursorY = m.CursorY - 1
            DIM upLen AS INTEGER = GetLineLength(m.Content, m.CursorY + 1)
            IF m.CursorX > upLen THEN
                m.CursorX = upLen
            ENDIF
        ENDIF
        m.SelectEndX = m.CursorX
        m.SelectEndY = m.CursorY
        RETURN m, NIL

    ELSEIF key = "shift+down" THEN
        StartSelection(@m)
        IF m.CursorY < totalLines - 1 THEN
            m.CursorY = m.CursorY + 1
            DIM downLen AS INTEGER = GetLineLength(m.Content, m.CursorY + 1)
            IF m.CursorX > downLen THEN
                m.CursorX = downLen
            ENDIF
        ENDIF
        m.SelectEndX = m.CursorX
        m.SelectEndY = m.CursorY
        RETURN m, NIL

    ELSEIF key = "shift+home" THEN
        StartSelection(@m)
        m.CursorX = 0
        m.SelectEndX = m.CursorX
        m.SelectEndY = m.CursorY
        RETURN m, NIL

    ELSEIF key = "shift+end" THEN
        StartSelection(@m)
        m.CursorX = currentLineLen
        m.SelectEndX = m.CursorX
        m.SelectEndY = m.CursorY
        RETURN m, NIL
    ENDIF

    ' Regular movement (clears selection)
    IF key = "left" THEN
        ClearSelection(@m)
        IF m.CursorX > 0 THEN
            m.CursorX = m.CursorX - 1
        ELSEIF m.CursorY > 0 THEN
            m.CursorY = m.CursorY - 1
            m.CursorX = GetLineLength(m.Content, m.CursorY + 1)
        ENDIF
        m.Message = ""

    ELSEIF key = "right" THEN
        ClearSelection(@m)
        IF m.CursorX < currentLineLen THEN
            m.CursorX = m.CursorX + 1
        ELSEIF m.CursorY < totalLines - 1 THEN
            m.CursorY = m.CursorY + 1
            m.CursorX = 0
        ENDIF
        m.Message = ""

    ELSEIF key = "up" THEN
        ClearSelection(@m)
        IF m.CursorY > 0 THEN
            m.CursorY = m.CursorY - 1
            DIM upLineLen AS INTEGER = GetLineLength(m.Content, m.CursorY + 1)
            IF m.CursorX > upLineLen THEN
                m.CursorX = upLineLen
            ENDIF
        ENDIF
        m.Message = ""

    ELSEIF key = "down" THEN
        ClearSelection(@m)
        IF m.CursorY < totalLines - 1 THEN
            m.CursorY = m.CursorY + 1
            DIM downLineLen AS INTEGER = GetLineLength(m.Content, m.CursorY + 1)
            IF m.CursorX > downLineLen THEN
                m.CursorX = downLineLen
            ENDIF
        ENDIF
        m.Message = ""

    ELSEIF key = "home" THEN
        ClearSelection(@m)
        m.CursorX = 0
        m.Message = ""

    ELSEIF key = "end" THEN
        ClearSelection(@m)
        m.CursorX = currentLineLen
        m.Message = ""

    ELSEIF key = "ctrl+home" THEN
        m.CursorX = 0
        m.CursorY = 0
        m.ScrollY = 0
        m.Message = ""

    ELSEIF key = "ctrl+end" THEN
        m.CursorY = totalLines - 1
        m.CursorX = GetLineLength(m.Content, totalLines)
        m.Message = ""

    ELSEIF key = "pgup" THEN
        DIM pgSize AS INTEGER = m.Height - 4
        IF pgSize < 1 THEN
            pgSize = 1
        ENDIF
        m.CursorY = m.CursorY - pgSize
        IF m.CursorY < 0 THEN
            m.CursorY = 0
        ENDIF
        m.Message = ""

    ELSEIF key = "pgdown" THEN
        DIM pgDownSize AS INTEGER = m.Height - 4
        IF pgDownSize < 1 THEN
            pgDownSize = 1
        ENDIF
        m.CursorY = m.CursorY + pgDownSize
        IF m.CursorY >= totalLines THEN
            m.CursorY = totalLines - 1
        ENDIF
        m.Message = ""

    ELSEIF key = "enter" THEN
        m.Content = InsertNewLine(m.Content, m.CursorY + 1, m.CursorX)
        m.CursorY = m.CursorY + 1
        m.CursorX = 0
        m.Modified = TRUE
        m.Message = ""

    ELSEIF key = "backspace" THEN
        IF m.CursorX > 0 THEN
            m.Content = DeleteCharAt(m.Content, m.CursorY + 1, m.CursorX - 1)
            m.CursorX = m.CursorX - 1
            m.Modified = TRUE
        ELSEIF m.CursorY > 0 THEN
            DIM prevLen AS INTEGER = GetLineLength(m.Content, m.CursorY)
            m.Content = JoinWithPrevLine(m.Content, m.CursorY + 1)
            m.CursorY = m.CursorY - 1
            m.CursorX = prevLen
            m.Modified = TRUE
        ENDIF
        m.Message = ""

    ELSEIF key = "delete" THEN
        IF m.CursorX < currentLineLen THEN
            m.Content = DeleteCharAt(m.Content, m.CursorY + 1, m.CursorX)
            m.Modified = TRUE
        ELSEIF m.CursorY < totalLines - 1 THEN
            ' Join next line
            DIM nextLine AS STRING = GetLine(m.Content, m.CursorY + 2)
            DIM currLine AS STRING = GetLine(m.Content, m.CursorY + 1)
            m.Content = SetLine(m.Content, m.CursorY + 1, currLine & nextLine)
            ' Remove the next line - rebuild without it
            DIM newContent AS STRING = ""
            DIM lineNum AS INTEGER = 1
            DIM total AS INTEGER = CountLines(m.Content)
            FOR lineNum = 1 TO total
                IF lineNum <> m.CursorY + 2 THEN
                    IF Len(newContent) > 0 THEN
                        newContent = newContent & Chr(10)
                    ENDIF
                    newContent = newContent & GetLine(m.Content, lineNum)
                ENDIF
            NEXT
            m.Content = newContent
            m.Modified = TRUE
        ENDIF
        m.Message = ""

    ELSEIF key = "tab" THEN
        DIM ti AS INTEGER
        FOR ti = 1 TO m.TabSize
            m.Content = InsertCharAt(m.Content, m.CursorY + 1, m.CursorX, " ")
            m.CursorX = m.CursorX + 1
        NEXT
        m.Modified = TRUE
        m.Message = ""

    ELSEIF key = "esc" THEN
        m.Selecting = FALSE
        m.Message = ""

    ELSEIF Len(key) = 1 THEN
        ' Regular character input
        IF m.InsertMode OR m.CursorX >= currentLineLen THEN
            m.Content = InsertCharAt(m.Content, m.CursorY + 1, m.CursorX, key)
        ELSE
            ' Overwrite mode
            m.Content = DeleteCharAt(m.Content, m.CursorY + 1, m.CursorX)
            m.Content = InsertCharAt(m.Content, m.CursorY + 1, m.CursorX, key)
        ENDIF
        m.CursorX = m.CursorX + 1
        m.Modified = TRUE
        m.Message = ""
    ENDIF

    ' Update scroll position
    DIM visibleLines AS INTEGER = m.Height - 4
    IF visibleLines < 1 THEN
        visibleLines = 1
    ENDIF

    IF m.CursorY < m.ScrollY THEN
        m.ScrollY = m.CursorY
    ELSEIF m.CursorY >= m.ScrollY + visibleLines THEN
        m.ScrollY = m.CursorY - visibleLines + 1
    ENDIF

    ' Horizontal scroll
    DIM visibleCols AS INTEGER = m.Width - 8
    IF m.ShowLineNumbers THEN
        visibleCols = visibleCols - 6
    ENDIF
    IF visibleCols < 10 THEN
        visibleCols = 10
    ENDIF

    IF m.CursorX < m.ScrollX THEN
        m.ScrollX = m.CursorX
    ELSEIF m.CursorX >= m.ScrollX + visibleCols THEN
        m.ScrollX = m.CursorX - visibleCols + 1
    ENDIF

    RETURN m, NIL
END FUNCTION

' Handle menu input
FUNCTION HandleMenuInput(m AS EditorModel, key AS STRING) AS (tea.Model, tea.Cmd)
    IF key = "esc" THEN
        m.MenuOpen = MENU_NONE
        RETURN m, NIL
    ELSEIF key = "left" THEN
        m.MenuOpen = m.MenuOpen - 1
        IF m.MenuOpen < MENU_FILE THEN
            m.MenuOpen = MENU_HELP
        ENDIF
        m.MenuIndex = 0
        RETURN m, NIL
    ELSEIF key = "right" THEN
        m.MenuOpen = m.MenuOpen + 1
        IF m.MenuOpen > MENU_HELP THEN
            m.MenuOpen = MENU_FILE
        ENDIF
        m.MenuIndex = 0
        RETURN m, NIL
    ELSEIF key = "up" THEN
        m.MenuIndex = m.MenuIndex - 1
        IF m.MenuIndex < 0 THEN
            m.MenuIndex = GetMenuItemCount(m.MenuOpen) - 1
        ENDIF
        RETURN m, NIL
    ELSEIF key = "down" THEN
        m.MenuIndex = m.MenuIndex + 1
        IF m.MenuIndex >= GetMenuItemCount(m.MenuOpen) THEN
            m.MenuIndex = 0
        ENDIF
        RETURN m, NIL
    ELSEIF key = "enter" THEN
        RETURN ExecuteMenuItem(m)
    ENDIF

    RETURN m, NIL
END FUNCTION

' Get menu item count
FUNCTION GetMenuItemCount(menu AS INTEGER) AS INTEGER
    IF menu = MENU_FILE THEN
        RETURN 6
    ELSEIF menu = MENU_EDIT THEN
        RETURN 6
    ELSEIF menu = MENU_SEARCH THEN
        RETURN 4
    ELSEIF menu = MENU_OPTIONS THEN
        RETURN 2
    ELSEIF menu = MENU_HELP THEN
        RETURN 2
    ENDIF
    RETURN 0
END FUNCTION

' Execute menu item
FUNCTION ExecuteMenuItem(m AS EditorModel) AS (tea.Model, tea.Cmd)
    DIM currentMenu AS INTEGER = m.MenuOpen
    m.MenuOpen = MENU_NONE

    IF currentMenu = MENU_FILE THEN
        IF m.MenuIndex = 0 THEN
            RETURN DoNewFile(m)
        ELSEIF m.MenuIndex = 1 THEN
            m.DialogMode = DIALOG_OPEN
            m.DialogInput = m.Filename
            m.DialogCursor = Len(m.DialogInput)
        ELSEIF m.MenuIndex = 2 THEN
            RETURN DoSaveFile(m)
        ELSEIF m.MenuIndex = 3 THEN
            m.DialogMode = DIALOG_SAVEAS
            m.DialogInput = m.Filename
            m.DialogCursor = Len(m.DialogInput)
        ELSEIF m.MenuIndex = 5 THEN
            IF m.Modified THEN
                m.DialogMode = DIALOG_CONFIRM_EXIT
            ELSE
                RETURN m, tea.Quit
            ENDIF
        ENDIF
    ELSEIF currentMenu = MENU_EDIT THEN
        IF m.MenuIndex = 0 THEN
            RETURN DoCut(m)
        ELSEIF m.MenuIndex = 1 THEN
            RETURN DoCopy(m)
        ELSEIF m.MenuIndex = 2 THEN
            RETURN DoPaste(m)
        ELSEIF m.MenuIndex = 4 THEN
            RETURN DoSelectAll(m)
        ENDIF
    ELSEIF currentMenu = MENU_SEARCH THEN
        IF m.MenuIndex = 0 THEN
            m.DialogMode = DIALOG_FIND
            m.DialogInput = m.SearchText
            m.DialogCursor = Len(m.DialogInput)
        ELSEIF m.MenuIndex = 1 THEN
            RETURN DoFindNext(m)
        ELSEIF m.MenuIndex = 2 THEN
            m.DialogMode = DIALOG_REPLACE
            m.DialogInput = m.SearchText
            m.DialogCursor = Len(m.DialogInput)
        ELSEIF m.MenuIndex = 3 THEN
            m.DialogMode = DIALOG_GOTO
            m.DialogInput = ""
            m.DialogCursor = 0
        ENDIF
    ELSEIF currentMenu = MENU_OPTIONS THEN
        IF m.MenuIndex = 0 THEN
            m.ShowLineNumbers = NOT m.ShowLineNumbers
        ELSEIF m.MenuIndex = 1 THEN
            m.InsertMode = NOT m.InsertMode
        ENDIF
    ELSEIF currentMenu = MENU_HELP THEN
        IF m.MenuIndex = 0 THEN
            m.DialogMode = DIALOG_HELP
        ELSEIF m.MenuIndex = 1 THEN
            m.DialogMode = DIALOG_ABOUT
        ENDIF
    ENDIF

    RETURN m, NIL
END FUNCTION

' Handle dialog input
FUNCTION HandleDialogInput(m AS EditorModel, key AS STRING) AS (tea.Model, tea.Cmd)
    IF key = "esc" THEN
        m.DialogMode = DIALOG_NONE
        RETURN m, NIL
    ENDIF

    ' Simple dialogs (just press any key)
    IF m.DialogMode = DIALOG_HELP OR m.DialogMode = DIALOG_ABOUT THEN
        IF key = "enter" OR key = "esc" OR key = " " THEN
            m.DialogMode = DIALOG_NONE
        ENDIF
        RETURN m, NIL
    ENDIF

    ' Confirmation dialogs
    IF m.DialogMode = DIALOG_CONFIRM_NEW OR m.DialogMode = DIALOG_CONFIRM_EXIT THEN
        IF key = "y" OR key = "Y" THEN
            IF m.DialogMode = DIALOG_CONFIRM_EXIT THEN
                RETURN m, tea.Quit
            ELSE
                m.Content = ""
                m.Filename = ""
                m.Modified = FALSE
                m.CursorX = 0
                m.CursorY = 0
                m.ScrollX = 0
                m.ScrollY = 0
                m.DialogMode = DIALOG_NONE
                m.Message = "New file"
            ENDIF
        ELSEIF key = "n" OR key = "N" OR key = "esc" THEN
            m.DialogMode = DIALOG_NONE
        ENDIF
        RETURN m, NIL
    ENDIF

    ' Text input dialogs
    IF key = "enter" THEN
        IF m.DialogMode = DIALOG_OPEN THEN
            RETURN DoOpenFile(m, m.DialogInput)
        ELSEIF m.DialogMode = DIALOG_SAVE OR m.DialogMode = DIALOG_SAVEAS THEN
            m.Filename = m.DialogInput
            RETURN DoSaveFile(m)
        ELSEIF m.DialogMode = DIALOG_FIND THEN
            m.SearchText = m.DialogInput
            m.DialogMode = DIALOG_NONE
            RETURN DoFindNext(m)
        ELSEIF m.DialogMode = DIALOG_REPLACE THEN
            m.SearchText = m.DialogInput
            m.DialogMode = DIALOG_NONE
            RETURN DoReplace(m)
        ELSEIF m.DialogMode = DIALOG_GOTO THEN
            RETURN DoGotoLine(m)
        ENDIF
    ELSEIF key = "backspace" THEN
        IF m.DialogCursor > 0 THEN
            m.DialogInput = Left(m.DialogInput, m.DialogCursor - 1) & Mid(m.DialogInput, m.DialogCursor + 1, Len(m.DialogInput) - m.DialogCursor)
            m.DialogCursor = m.DialogCursor - 1
        ENDIF
    ELSEIF key = "delete" THEN
        IF m.DialogCursor < Len(m.DialogInput) THEN
            m.DialogInput = Left(m.DialogInput, m.DialogCursor) & Mid(m.DialogInput, m.DialogCursor + 2, Len(m.DialogInput) - m.DialogCursor - 1)
        ENDIF
    ELSEIF key = "left" THEN
        IF m.DialogCursor > 0 THEN
            m.DialogCursor = m.DialogCursor - 1
        ENDIF
    ELSEIF key = "right" THEN
        IF m.DialogCursor < Len(m.DialogInput) THEN
            m.DialogCursor = m.DialogCursor + 1
        ENDIF
    ELSEIF key = "home" THEN
        m.DialogCursor = 0
    ELSEIF key = "end" THEN
        m.DialogCursor = Len(m.DialogInput)
    ELSEIF Len(key) = 1 THEN
        m.DialogInput = Left(m.DialogInput, m.DialogCursor) & key & Mid(m.DialogInput, m.DialogCursor + 1, Len(m.DialogInput) - m.DialogCursor)
        m.DialogCursor = m.DialogCursor + 1
    ENDIF

    RETURN m, NIL
END FUNCTION

' File operations
FUNCTION DoNewFile(m AS EditorModel) AS (tea.Model, tea.Cmd)
    IF m.Modified THEN
        m.DialogMode = DIALOG_CONFIRM_NEW
        RETURN m, NIL
    ENDIF
    m.Content = ""
    m.Filename = ""
    m.Modified = FALSE
    m.CursorX = 0
    m.CursorY = 0
    m.ScrollX = 0
    m.ScrollY = 0
    m.Message = "New file"
    RETURN m, NIL
END FUNCTION

FUNCTION DoOpenFile(m AS EditorModel, filename AS STRING) AS (tea.Model, tea.Cmd)
    m.DialogMode = DIALOG_NONE

    IF Len(filename) = 0 THEN
        m.Message = "No filename specified"
        RETURN m, NIL
    ENDIF

    DIM content AS STRING = ReadFile(filename)
    IF Len(content) = 0 AND NOT FileExists(filename) THEN
        m.Message = "File not found: " & filename
        RETURN m, NIL
    ENDIF

    m.Content = content
    m.Filename = filename
    m.Modified = FALSE
    m.CursorX = 0
    m.CursorY = 0
    m.ScrollX = 0
    m.ScrollY = 0
    m.Message = "Opened: " & filename
    RETURN m, NIL
END FUNCTION

FUNCTION DoSaveFile(m AS EditorModel) AS (tea.Model, tea.Cmd)
    IF Len(m.Filename) = 0 THEN
        m.DialogMode = DIALOG_SAVEAS
        m.DialogInput = ""
        m.DialogCursor = 0
        RETURN m, NIL
    ENDIF

    m.DialogMode = DIALOG_NONE
    WriteFile(m.Filename, m.Content)
    m.Modified = FALSE
    m.Message = "Saved: " & m.Filename
    RETURN m, NIL
END FUNCTION

' Check if a position is within selection
FUNCTION IsInSelection(m AS EditorModel, row AS INTEGER, col AS INTEGER) AS BOOLEAN
    IF NOT m.Selecting THEN
        RETURN FALSE
    ENDIF

    DIM startY AS INTEGER
    DIM startX AS INTEGER
    DIM endY AS INTEGER
    DIM endX AS INTEGER
    startY, startX, endY, endX = GetSelectionBounds(m)

    IF row < startY OR row > endY THEN
        RETURN FALSE
    ENDIF

    IF row = startY AND row = endY THEN
        RETURN col >= startX AND col < endX
    ELSEIF row = startY THEN
        RETURN col >= startX
    ELSEIF row = endY THEN
        RETURN col < endX
    ELSE
        RETURN TRUE
    ENDIF
END FUNCTION

' Get normalized selection bounds (start before end)
FUNCTION GetSelectionBounds(m AS EditorModel) AS (INTEGER, INTEGER, INTEGER, INTEGER)
    DIM startY AS INTEGER = m.SelectStartY
    DIM startX AS INTEGER = m.SelectStartX
    DIM endY AS INTEGER = m.SelectEndY
    DIM endX AS INTEGER = m.SelectEndX

    ' Swap if end is before start
    IF endY < startY OR (endY = startY AND endX < startX) THEN
        DIM tmpY AS INTEGER = startY
        DIM tmpX AS INTEGER = startX
        startY = endY
        startX = endX
        endY = tmpY
        endX = tmpX
    ENDIF

    RETURN startY, startX, endY, endX
END FUNCTION

' Get selected text
FUNCTION GetSelectedText(m AS EditorModel) AS STRING
    IF NOT m.Selecting THEN
        RETURN ""
    ENDIF

    DIM startY AS INTEGER
    DIM startX AS INTEGER
    DIM endY AS INTEGER
    DIM endX AS INTEGER
    startY, startX, endY, endX = GetSelectionBounds(m)

    DIM result AS STRING = ""
    DIM y AS INTEGER

    FOR y = startY TO endY
        DIM line AS STRING = GetLine(m.Content, y + 1)
        DIM lineStart AS INTEGER = 0
        DIM lineEnd AS INTEGER = Len(line)

        IF y = startY THEN
            lineStart = startX
        ENDIF
        IF y = endY THEN
            lineEnd = endX
        ENDIF

        IF lineEnd > lineStart THEN
            result = result & Mid(line, lineStart + 1, lineEnd - lineStart)
        ENDIF

        IF y < endY THEN
            result = result & Chr(10)
        ENDIF
    NEXT

    RETURN result
END FUNCTION

' Delete selected text and return the position to place cursor
FUNCTION DeleteSelection(m AS POINTER TO EditorModel) AS (INTEGER, INTEGER)
    IF NOT (^m).Selecting THEN
        RETURN (^m).CursorX, (^m).CursorY
    ENDIF

    DIM startY AS INTEGER
    DIM startX AS INTEGER
    DIM endY AS INTEGER
    DIM endX AS INTEGER
    startY, startX, endY, endX = GetSelectionBounds(^m)

    ' Build new content without selected text
    DIM totalLines AS INTEGER = CountLines((^m).Content)
    DIM newContent AS STRING = ""
    DIM y AS INTEGER

    FOR y = 0 TO totalLines - 1
        DIM line AS STRING = GetLine((^m).Content, y + 1)

        IF y < startY OR y > endY THEN
            ' Line not in selection - keep as is
            IF Len(newContent) > 0 THEN
                newContent = newContent & Chr(10)
            ENDIF
            newContent = newContent & line
        ELSEIF y = startY AND y = endY THEN
            ' Selection within one line
            IF Len(newContent) > 0 THEN
                newContent = newContent & Chr(10)
            ENDIF
            newContent = newContent & Left(line, startX) & Mid(line, endX + 1, Len(line) - endX)
        ELSEIF y = startY THEN
            ' First line of multi-line selection
            IF Len(newContent) > 0 THEN
                newContent = newContent & Chr(10)
            ENDIF
            newContent = newContent & Left(line, startX)
        ELSEIF y = endY THEN
            ' Last line of multi-line selection - join with first line
            newContent = newContent & Mid(line, endX + 1, Len(line) - endX)
        ENDIF
        ' Lines between startY and endY are skipped entirely
    NEXT

    (^m).Content = newContent
    (^m).Selecting = FALSE
    (^m).Modified = TRUE

    RETURN startX, startY
END FUNCTION

' Edit operations
FUNCTION DoCopy(m AS EditorModel) AS (tea.Model, tea.Cmd)
    IF m.Selecting THEN
        m.Clipboard = GetSelectedText(m)
        m.Message = "Copied"
    ELSE
        ' Copy current line
        m.Clipboard = GetLine(m.Content, m.CursorY + 1)
        m.Message = "Line copied"
    ENDIF
    RETURN m, NIL
END FUNCTION

FUNCTION DoCut(m AS EditorModel) AS (tea.Model, tea.Cmd)
    IF m.Selecting THEN
        m.Clipboard = GetSelectedText(m)
        DIM newX AS INTEGER
        DIM newY AS INTEGER
        newX, newY = DeleteSelection(@m)
        m.CursorX = newX
        m.CursorY = newY
        m.Message = "Cut"
    ELSE
        m.Clipboard = GetLine(m.Content, m.CursorY + 1)

        ' Remove current line
        DIM totalLines AS INTEGER = CountLines(m.Content)
        IF totalLines = 1 THEN
            m.Content = ""
        ELSE
            DIM newContent AS STRING = ""
            DIM i AS INTEGER
            FOR i = 1 TO totalLines
                IF i <> m.CursorY + 1 THEN
                    IF Len(newContent) > 0 THEN
                        newContent = newContent & Chr(10)
                    ENDIF
                    newContent = newContent & GetLine(m.Content, i)
                ENDIF
            NEXT
            m.Content = newContent
        ENDIF

        IF m.CursorY >= CountLines(m.Content) THEN
            m.CursorY = CountLines(m.Content) - 1
            IF m.CursorY < 0 THEN
                m.CursorY = 0
            ENDIF
        ENDIF

        DIM newLineLen AS INTEGER = GetLineLength(m.Content, m.CursorY + 1)
        IF m.CursorX > newLineLen THEN
            m.CursorX = newLineLen
        ENDIF

        m.Modified = TRUE
        m.Message = "Line cut"
    ENDIF
    RETURN m, NIL
END FUNCTION

FUNCTION DoPaste(m AS EditorModel) AS (tea.Model, tea.Cmd)
    IF Len(m.Clipboard) = 0 THEN
        m.Message = "Clipboard empty"
        RETURN m, NIL
    ENDIF

    ' Delete selection first if any
    IF m.Selecting THEN
        DIM delX AS INTEGER
        DIM delY AS INTEGER
        delX, delY = DeleteSelection(@m)
        m.CursorX = delX
        m.CursorY = delY
    ENDIF

    ' Insert clipboard at cursor position
    DIM clipLines AS INTEGER = CountLines(m.Clipboard)

    IF clipLines = 1 THEN
        ' Single line paste - insert at cursor
        DIM line AS STRING = GetLine(m.Content, m.CursorY + 1)
        DIM newLine AS STRING = Left(line, m.CursorX) & m.Clipboard & Mid(line, m.CursorX + 1, Len(line) - m.CursorX)
        m.Content = SetLine(m.Content, m.CursorY + 1, newLine)
        m.CursorX = m.CursorX + Len(m.Clipboard)
    ELSE
        ' Multi-line paste
        DIM currentLine AS STRING = GetLine(m.Content, m.CursorY + 1)
        DIM beforeCursor AS STRING = Left(currentLine, m.CursorX)
        DIM afterCursor AS STRING = Mid(currentLine, m.CursorX + 1, Len(currentLine) - m.CursorX)

        DIM newContent AS STRING = ""
        DIM totalLines AS INTEGER = CountLines(m.Content)
        DIM y AS INTEGER

        FOR y = 1 TO totalLines
            IF y = m.CursorY + 1 THEN
                ' Insert clipboard here
                DIM clipY AS INTEGER
                FOR clipY = 1 TO clipLines
                    IF Len(newContent) > 0 THEN
                        newContent = newContent & Chr(10)
                    ENDIF
                    IF clipY = 1 THEN
                        newContent = newContent & beforeCursor & GetLine(m.Clipboard, clipY)
                    ELSEIF clipY = clipLines THEN
                        newContent = newContent & GetLine(m.Clipboard, clipY) & afterCursor
                    ELSE
                        newContent = newContent & GetLine(m.Clipboard, clipY)
                    ENDIF
                NEXT
            ELSE
                IF Len(newContent) > 0 THEN
                    newContent = newContent & Chr(10)
                ENDIF
                newContent = newContent & GetLine(m.Content, y)
            ENDIF
        NEXT

        m.Content = newContent
        m.CursorY = m.CursorY + clipLines - 1
        m.CursorX = Len(GetLine(m.Clipboard, clipLines))
    ENDIF

    m.Modified = TRUE
    m.Message = "Pasted"
    RETURN m, NIL
END FUNCTION

FUNCTION DoSelectAll(m AS EditorModel) AS (tea.Model, tea.Cmd)
    DIM totalLines AS INTEGER = CountLines(m.Content)
    m.Selecting = TRUE
    m.SelectStartX = 0
    m.SelectStartY = 0
    m.SelectEndY = totalLines - 1
    m.SelectEndX = GetLineLength(m.Content, totalLines)
    m.CursorY = m.SelectEndY
    m.CursorX = m.SelectEndX
    m.Message = "All selected"
    RETURN m, NIL
END FUNCTION

' Search operations
FUNCTION DoFindNext(m AS EditorModel) AS (tea.Model, tea.Cmd)
    IF Len(m.SearchText) = 0 THEN
        m.Message = "No search text"
        RETURN m, NIL
    ENDIF

    ' Search from current position
    DIM totalLines AS INTEGER = CountLines(m.Content)
    DIM startLine AS INTEGER = m.CursorY + 1
    DIM startCol AS INTEGER = m.CursorX + 1
    DIM i AS INTEGER

    FOR i = startLine TO totalLines
        DIM line AS STRING = GetLine(m.Content, i)
        DIM searchStart AS INTEGER = 1
        IF i = startLine THEN
            searchStart = startCol + 1
        ENDIF

        DIM pos AS INTEGER = Instr(Mid(line, searchStart, Len(line) - searchStart + 1), m.SearchText)
        IF pos > 0 THEN
            m.CursorY = i - 1
            m.CursorX = searchStart - 1 + pos - 1
            m.Message = "Found"
            RETURN m, NIL
        ENDIF
    NEXT

    ' Wrap around if enabled
    IF m.SearchWrap THEN
        FOR i = 1 TO startLine
            DIM wrapLine AS STRING = GetLine(m.Content, i)
            DIM wrapPos AS INTEGER = Instr(wrapLine, m.SearchText)
            IF wrapPos > 0 THEN
                m.CursorY = i - 1
                m.CursorX = wrapPos - 1
                m.Message = "Found (wrapped)"
                RETURN m, NIL
            ENDIF
        NEXT
    ENDIF

    m.Message = "Not found: " & m.SearchText
    RETURN m, NIL
END FUNCTION

FUNCTION DoReplace(m AS EditorModel) AS (tea.Model, tea.Cmd)
    m.Message = "Replace not yet implemented"
    RETURN m, NIL
END FUNCTION

FUNCTION DoGotoLine(m AS EditorModel) AS (tea.Model, tea.Cmd)
    m.DialogMode = DIALOG_NONE
    DIM lineNum AS INTEGER = Int(Val(m.DialogInput))
    DIM totalLines AS INTEGER = CountLines(m.Content)

    IF lineNum < 1 THEN
        lineNum = 1
    ELSEIF lineNum > totalLines THEN
        lineNum = totalLines
    ENDIF

    m.CursorY = lineNum - 1
    m.CursorX = 0
    m.Message = fmt.Sprintf("Line %d", lineNum)
    RETURN m, NIL
END FUNCTION

' View renders the editor
FUNCTION (m AS EditorModel) View() AS STRING
    DIM view AS STRING = ""
    DIM totalLines AS INTEGER = CountLines(m.Content)

    ' Render menu bar
    view = RenderMenuBar(m) & Chr(10)

    ' Render dropdown if menu is open
    IF m.MenuOpen <> MENU_NONE THEN
        view = view & RenderDropdown(m)
    ENDIF

    ' Calculate content area
    DIM contentHeight AS INTEGER = m.Height - 3
    IF contentHeight < 1 THEN
        contentHeight = 1
    ENDIF

    ' Render content lines
    DIM lineNumWidth AS INTEGER = 0
    IF m.ShowLineNumbers THEN
        lineNumWidth = 6
    ENDIF

    DIM contentWidth AS INTEGER = m.Width - lineNumWidth
    IF contentWidth < 10 THEN
        contentWidth = 10
    ENDIF

    DIM i AS INTEGER
    FOR i = 0 TO contentHeight - 1
        DIM lineIdx AS INTEGER = m.ScrollY + i
        DIM lineText AS STRING = ""

        IF lineIdx < totalLines THEN
            lineText = GetLine(m.Content, lineIdx + 1)
        ENDIF

        ' Apply horizontal scroll
        IF m.ScrollX > 0 AND Len(lineText) > m.ScrollX THEN
            lineText = Mid(lineText, m.ScrollX + 1, Len(lineText) - m.ScrollX)
        ELSEIF m.ScrollX > 0 THEN
            lineText = ""
        ENDIF

        ' Line number
        IF m.ShowLineNumbers THEN
            IF lineIdx < totalLines THEN
                view = view & lineNumStyle.Render(fmt.Sprintf("%5d ", lineIdx + 1))
            ELSE
                view = view & lineNumStyle.Render("      ")
            ENDIF
        ENDIF

        ' Render content with selection highlighting and cursor
        DIM lineContent AS STRING = ""
        DIM col AS INTEGER
        DIM cursorCol AS INTEGER = m.CursorX - m.ScrollX
        DIM renderedLen AS INTEGER = 0

        FOR col = 0 TO contentWidth - 1
            DIM actualCol AS INTEGER = m.ScrollX + col
            DIM ch AS STRING = " "

            IF col < Len(lineText) THEN
                ch = Mid(lineText, col + 1, 1)
            ENDIF

            ' Check if cursor is here
            IF lineIdx = m.CursorY AND col = cursorCol THEN
                lineContent = lineContent & cursorStyle.Render(ch)
            ELSEIF IsInSelection(m, lineIdx, actualCol) THEN
                lineContent = lineContent & selectedStyle.Render(ch)
            ELSE
                lineContent = lineContent & textAreaStyle.Render(ch)
            ENDIF
            renderedLen = renderedLen + 1
        NEXT

        view = view & lineContent

        view = view & Chr(10)
    NEXT

    ' Status bar
    DIM status AS STRING = ""
    IF Len(m.Filename) > 0 THEN
        status = " " & m.Filename
    ELSE
        status = " [Untitled]"
    ENDIF
    IF m.Modified THEN
        status = status & " *"
    ENDIF
    status = status & fmt.Sprintf("  Ln %d, Col %d", m.CursorY + 1, m.CursorX + 1)
    IF NOT m.InsertMode THEN
        status = status & "  OVR"
    ENDIF
    IF Len(m.Message) > 0 THEN
        status = status & "  " & m.Message
    ENDIF
    view = view & statusBarStyle.Render(PadRight(status, m.Width)) & Chr(10)

    ' Help line
    view = view & menuBarStyle.Render(PadRight(" F1=Help  F10=Menu  Ctrl+S=Save  Ctrl+Q=Quit", m.Width))

    ' Render dialog if open
    IF m.DialogMode <> DIALOG_NONE THEN
        view = view & Chr(10) & RenderDialog(m)
    ENDIF

    RETURN view
END FUNCTION

' Render a menu item with highlighted hotkey
FUNCTION RenderMenuItemWithHotkey(name AS STRING, hotkeyPos AS INTEGER, selected AS BOOLEAN) AS STRING
    DIM before AS STRING = Left(name, hotkeyPos - 1)
    DIM hotkey AS STRING = Mid(name, hotkeyPos, 1)
    DIM after AS STRING = Mid(name, hotkeyPos + 1, Len(name) - hotkeyPos)

    IF selected THEN
        RETURN menuItemSelectedStyle.Render(" " & before) & menuHotkeySelectedStyle.Render(hotkey) & menuItemSelectedStyle.Render(after & " ")
    ELSE
        RETURN menuItemStyle.Render(" " & before) & menuHotkeyStyle.Render(hotkey) & menuItemStyle.Render(after & " ")
    ENDIF
END FUNCTION

' Render menu bar
FUNCTION RenderMenuBar(m AS EditorModel) AS STRING
    DIM bar AS STRING = ""

    ' File (F is hotkey at position 1)
    bar = bar & RenderMenuItemWithHotkey("File", 1, m.MenuOpen = MENU_FILE)

    ' Edit (E is hotkey at position 1)
    bar = bar & RenderMenuItemWithHotkey("Edit", 1, m.MenuOpen = MENU_EDIT)

    ' Search (S is hotkey at position 1)
    bar = bar & RenderMenuItemWithHotkey("Search", 1, m.MenuOpen = MENU_SEARCH)

    ' Options (O is hotkey at position 1)
    bar = bar & RenderMenuItemWithHotkey("Options", 1, m.MenuOpen = MENU_OPTIONS)

    ' Help (H is hotkey at position 1)
    bar = bar & RenderMenuItemWithHotkey("Help", 1, m.MenuOpen = MENU_HELP)

    ' Pad to full width
    DIM currentLen AS INTEGER = 38
    IF m.Width > currentLen THEN
        bar = bar & menuBarStyle.Render(RepeatChar(" ", m.Width - currentLen))
    ENDIF

    RETURN bar
END FUNCTION

' Render dropdown menu
FUNCTION RenderDropdown(m AS EditorModel) AS STRING
    DIM items AS STRING = ""

    IF m.MenuOpen = MENU_FILE THEN
        items = RenderMenuItem("New         Ctrl+N", m.MenuIndex = 0) & Chr(10)
        items = items & RenderMenuItem("Open        Ctrl+O", m.MenuIndex = 1) & Chr(10)
        items = items & RenderMenuItem("Save        Ctrl+S", m.MenuIndex = 2) & Chr(10)
        items = items & RenderMenuItem("Save As...       ", m.MenuIndex = 3) & Chr(10)
        items = items & RenderMenuItem("-----------------", FALSE) & Chr(10)
        items = items & RenderMenuItem("Exit        Alt+X ", m.MenuIndex = 5)
    ELSEIF m.MenuOpen = MENU_EDIT THEN
        items = RenderMenuItem("Cut         Ctrl+X", m.MenuIndex = 0) & Chr(10)
        items = items & RenderMenuItem("Copy        Ctrl+C", m.MenuIndex = 1) & Chr(10)
        items = items & RenderMenuItem("Paste       Ctrl+V", m.MenuIndex = 2) & Chr(10)
        items = items & RenderMenuItem("-----------------", FALSE) & Chr(10)
        items = items & RenderMenuItem("Select All  Ctrl+A", m.MenuIndex = 4) & Chr(10)
        items = items & RenderMenuItem("Clear            ", m.MenuIndex = 5)
    ELSEIF m.MenuOpen = MENU_SEARCH THEN
        items = RenderMenuItem("Find        Ctrl+F", m.MenuIndex = 0) & Chr(10)
        items = items & RenderMenuItem("Find Next   F3    ", m.MenuIndex = 1) & Chr(10)
        items = items & RenderMenuItem("Replace     Ctrl+H", m.MenuIndex = 2) & Chr(10)
        items = items & RenderMenuItem("Go to Line  Ctrl+G", m.MenuIndex = 3)
    ELSEIF m.MenuOpen = MENU_OPTIONS THEN
        DIM lineNumCheck AS STRING = "[ ]"
        IF m.ShowLineNumbers THEN
            lineNumCheck = "[X]"
        ENDIF
        DIM insertCheck AS STRING = "[ ]"
        IF m.InsertMode THEN
            insertCheck = "[X]"
        ENDIF
        items = RenderMenuItem(lineNumCheck & " Line Numbers ", m.MenuIndex = 0) & Chr(10)
        items = items & RenderMenuItem(insertCheck & " Insert Mode  ", m.MenuIndex = 1)
    ELSEIF m.MenuOpen = MENU_HELP THEN
        items = RenderMenuItem("Help        F1    ", m.MenuIndex = 0) & Chr(10)
        items = items & RenderMenuItem("About            ", m.MenuIndex = 1)
    ENDIF

    RETURN menuDropdownStyle.Render(items) & Chr(10)
END FUNCTION

' Render a single menu item
FUNCTION RenderMenuItem(text AS STRING, selected AS BOOLEAN) AS STRING
    IF selected THEN
        RETURN menuItemSelectedStyle.Render(text)
    ENDIF
    RETURN text
END FUNCTION

' Render dialog box
FUNCTION RenderDialog(m AS EditorModel) AS STRING
    DIM content AS STRING = ""
    DIM title AS STRING = ""

    IF m.DialogMode = DIALOG_HELP THEN
        title = " Help "
        content = "MS-DOS Editor Clone - Keyboard Shortcuts" & Chr(10) & Chr(10)
        content = content & "File Operations:" & Chr(10)
        content = content & "  Ctrl+N    New file" & Chr(10)
        content = content & "  Ctrl+O    Open file" & Chr(10)
        content = content & "  Ctrl+S    Save file" & Chr(10)
        content = content & "  Ctrl+Q    Exit" & Chr(10) & Chr(10)
        content = content & "Edit Operations:" & Chr(10)
        content = content & "  Ctrl+C    Copy line" & Chr(10)
        content = content & "  Ctrl+X    Cut line" & Chr(10)
        content = content & "  Ctrl+V    Paste" & Chr(10) & Chr(10)
        content = content & "Navigation:" & Chr(10)
        content = content & "  Arrow keys, Home, End, PgUp, PgDn" & Chr(10)
        content = content & "  Ctrl+Home/End  Start/end of file" & Chr(10) & Chr(10)
        content = content & "Search:" & Chr(10)
        content = content & "  Ctrl+F    Find" & Chr(10)
        content = content & "  F3        Find next" & Chr(10)
        content = content & "  Ctrl+G    Go to line" & Chr(10) & Chr(10)
        content = content & "Press Enter or Esc to close"

    ELSEIF m.DialogMode = DIALOG_ABOUT THEN
        title = " About "
        content = "DBasic EDIT" & Chr(10)
        content = content & "Version 1.0" & Chr(10) & Chr(10)
        content = content & "A clone of MS-DOS 5.0 EDIT.COM" & Chr(10)
        content = content & "Written entirely in DBasic" & Chr(10) & Chr(10)
        content = content & "Press Enter or Esc to close"

    ELSEIF m.DialogMode = DIALOG_OPEN THEN
        title = " Open File "
        content = "Filename:" & Chr(10) & Chr(10)
        content = content & "[" & m.DialogInput & "]" & Chr(10) & Chr(10)
        content = content & "Enter=Open  Esc=Cancel"

    ELSEIF m.DialogMode = DIALOG_SAVEAS THEN
        title = " Save As "
        content = "Filename:" & Chr(10) & Chr(10)
        content = content & "[" & m.DialogInput & "]" & Chr(10) & Chr(10)
        content = content & "Enter=Save  Esc=Cancel"

    ELSEIF m.DialogMode = DIALOG_FIND THEN
        title = " Find "
        content = "Search for:" & Chr(10) & Chr(10)
        content = content & "[" & m.DialogInput & "]" & Chr(10) & Chr(10)
        content = content & "Enter=Find  Esc=Cancel"

    ELSEIF m.DialogMode = DIALOG_GOTO THEN
        title = " Go to Line "
        content = "Line number:" & Chr(10) & Chr(10)
        content = content & "[" & m.DialogInput & "]" & Chr(10) & Chr(10)
        content = content & "Enter=Go  Esc=Cancel"

    ELSEIF m.DialogMode = DIALOG_CONFIRM_NEW THEN
        title = " New File "
        content = "File has been modified." & Chr(10) & Chr(10)
        content = content & "Discard changes? (Y/N)"

    ELSEIF m.DialogMode = DIALOG_CONFIRM_EXIT THEN
        title = " Exit "
        content = "File has been modified." & Chr(10) & Chr(10)
        content = content & "Exit without saving? (Y/N)"
    ENDIF

    RETURN dialogTitleStyle.Render(title) & Chr(10) & dialogStyle.Render(content)
END FUNCTION

' Main entry point
SUB Main()
    DIM model AS EditorModel
    model.CursorX = 0
    model.CursorY = 0
    model.Width = 80
    model.Height = 25
    model.ScrollX = 0
    model.ScrollY = 0
    model.SelectStartX = 0
    model.SelectStartY = 0
    model.SelectEndX = 0
    model.SelectEndY = 0
    model.Selecting = FALSE
    model.Clipboard = ""
    model.Filename = ""
    model.Modified = FALSE
    model.MenuOpen = MENU_NONE
    model.MenuIndex = 0
    model.DialogMode = DIALOG_NONE
    model.DialogInput = ""
    model.DialogCursor = 0
    model.SearchText = ""
    model.ReplaceText = ""
    model.SearchWrap = TRUE
    model.SearchCase = FALSE
    model.Message = "Press F1 for Help, F10 for Menu"
    model.ShowLineNumbers = FALSE
    model.TabSize = 4
    model.InsertMode = TRUE

    ' Check for command line argument (file to open)
    DIM args AS []STRING = os.Args
    IF Len(args) > 1 THEN
        DIM filename AS STRING = args[1]
        IF FileExists(filename) THEN
            model.Content = ReadFile(filename)
            model.Filename = filename
            model.Message = "Opened: " & filename
        ELSE
            model.Filename = filename
            model.Message = "New file: " & filename
        ENDIF
    ELSE
        ' Default welcome content
        model.Content = "' Welcome to DBasic EDIT" & Chr(10)
        model.Content = model.Content & "' A clone of MS-DOS 5.0 EDIT.COM" & Chr(10)
        model.Content = model.Content & "'" & Chr(10)
        model.Content = model.Content & "' Press F10 or Alt+F to open the menu" & Chr(10)
        model.Content = model.Content & "' Press F1 for help" & Chr(10)
        model.Content = model.Content & "'" & Chr(10)
        model.Content = model.Content & "' Start typing to edit..." & Chr(10)
    ENDIF

    tea.NewProgram(model, tea.WithAltScreen()).Run()
END SUB
